import random
import numpy as np
import pandas as pd
import scipy.sparse as sp
import torch.utils.data as data
import torch


class PointData(data.Dataset):
    def __init__(self, neg_set, is_training=True, context=False, neg_label_val=0.):
        """
        Dataset formatter adapted point-wise algorithms
        Parameters
        ----------
        neg_set : List, negative sampled result generated by Sampler
        is_training : boolean, whether the procedure using this method is training part
        neg_label_val : float, rating value towards negative sample
        """
        super(PointData, self).__init__()
        self.features_fill = []
        self.labels_fill = []
        self.context = context
        if context:
            for u, i, c, r, js in neg_set:
                self.features_fill.append([int(u), int(i), int(c)])
                self.labels_fill.append(r)

                if is_training:
                    for j in js:
                        self.features_fill.append([int(u), int(j), int(c)])
                        self.labels_fill.append(neg_label_val)
        else:
            for u, i, r, js in neg_set:
                self.features_fill.append([int(u), int(i)])
                self.labels_fill.append(r)

                if is_training:
                    for j in js:
                        self.features_fill.append([int(u), int(j)])
                        self.labels_fill.append(neg_label_val)
        self.labels_fill = np.array(self.labels_fill, dtype=np.float32)

    def __len__(self):
        return len(self.labels_fill)

    def __getitem__(self, idx):
        features = self.features_fill
        labels = self.labels_fill

        user = features[idx][0]
        item = features[idx][1]
        context = features[idx][2] if self.context else []
        label = labels[idx]

        return user, item, context, label


class PairData(data.Dataset):
    def __init__(self, neg_set, context=False, is_training=True):
        """
        Dataset formatter adapted pair-wise algorithms
        Parameters
        ----------
        neg_set : List,
        is_training : bool,
        """
        super(PairData, self).__init__()
        self.features_fill = []
        self.context = context

        if context:
            for u, i, c, r, js in neg_set:
                u, i, c, r = int(u), int(i), int(c), np.float32(1)
                if is_training:
                    for j in js:
                        self.features_fill.append([u, i, c, j, r])
                else:
                    self.features_fill.append([u, i, c, i, r])
        else:
            for u, i, r, js in neg_set:
                u, i, r = int(u), int(i), np.float32(1)
                if is_training:
                    for j in js:
                        self.features_fill.append([u, i, j, r])
                else:
                    self.features_fill.append([u, i, i, r])

    def __len__(self):
        return len(self.features_fill)

    def __getitem__(self, idx):
        features = self.features_fill
        user = features[idx][0]
        item_i = features[idx][1]
        context = features[idx][2] if self.context else []
        item_j = features[idx][3] if self.context else features[idx][2]
        label = features[idx][4] if self.context else features[idx][3]

        return user, item_i, context, item_j, label


def sparse_mx_to_torch_sparse_tensor(sparse_mx):
    """
    Convert a scipy sparse matrix to a torch sparse tensor.
    :param sparse_mx: Scipy sparse matrix.
    :return: Torch sparse tensor.
    """
    sparse_mx = sparse_mx.tocoo().astype(np.float32)
    indices = torch.from_numpy(
        np.vstack((sparse_mx.row, sparse_mx.col)).astype(np.int64))
    values = torch.from_numpy(sparse_mx.data)
    shape = torch.Size(sparse_mx.shape)
    return torch.sparse.FloatTensor(indices, values, shape)